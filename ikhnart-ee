FeatureCollection([
  ee.Feature(
    ee.Geometry.Rectangle(108.5471, 45.33891, 108.8689, 45.86695),
    {name: 'Ikh Nart'})]);
    
// initial variables
var geometry = ikhnart;
var clipper = function(img)
  {return img.clip(geometry)};
// Define a FeatureCollection: Ikh Nart and Do
var bands = ['B5', 'B4', 'B3', 'B2', 'B1'];
var L5coll = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
.filter(ee.Filter.lt('CLOUD_COVER',25))
.select(bands)
.filterBounds(geometry)

var L7coll = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')
.filter(ee.Filter.lt('CLOUD_COVER',25))
.select(bands)
.filterBounds(geometry)
.map(function(image){
  var filled1a = image.focal_mean(1, 'square', 'pixels', 2)
  return filled1a.blend(image);
})

var L8coll = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
.filter(ee.Filter.lt('CLOUD_COVER',5))
.filterBounds(geometry)
.map(function(image){
  return image.rename(['B0', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B9', 'B10', 'B11']);
})
.select(bands);

// This function adds a band representing the image timestamp.
var addTime = function(image) {
  return image.addBands(image.metadata('system:time_start')
    .divide(1000 * 60 * 60 * 24 * 365));
};

var addNDVI = function(image) {
  var ndvi = image.normalizedDifference(['B4', 'B3']).rename('NDVI');
  return image.addBands(ndvi);
};

var fill = function(image){
                var filled1a = image.focal_mean(2, 'square', 'pixels', 1).blend(image);
                return filled1a.set('system:time_start',image.get('system:time_start'));
};

var landsat = ee.ImageCollection(L5coll.merge(L7coll.merge(L8coll)))
  .map(addNDVI)
  .map(fill);
  



//print(nullimages);

var years = ee.List.sequence(1984, 2019);
//print (years);

var collectYear = ee.ImageCollection(years
  .map(function(y) {
      var start = ee.Date.fromYMD(y, 1, 1)
      var end = start.advance(12, 'month');
      return landsat.filterDate(start, end).reduce(ee.Reducer.median())
  }));
  
/*
var medianFirst = collection_merge.first()
var finalCollection = nullimages.map(function(image){
  return image.visualize({bands: ['B3_median', 'B2_median', 'B1_median'], min: 300, max: 1800});
})
Map.addLayer(medianFirst, {bands: ['B3', 'B2', 'B1'], min: 0, max: 3000}, 'first image');
*/
/*
Export.video.toDrive({
  collection: finalCollection,
  description: 'yearly-ikhnart',
  dimensions: 1080,
  framesPerSecond: 1,
  region: geometry
});
*/

/*
var dem = ee.Image('USGS/SRTMGL1_003').clip(geometry);
var elevation = dem.select('elevation');
var slope = ee.Terrain.slope(elevation);

//Map.addLayer(features, {}, 'Ikh Nart')
Map.setCenter(108.7, 45.6, 9); // Ikh Nart
Map.addLayer(elevation, {min: 0, max:3500}, 'elevation')
Map.addLayer(slope, {min: 0, max: 60}, 'slope');
*/


var climate = ee.ImageCollection('IDAHO_EPSCOR/TERRACLIMATE')
                  .filter(ee.Filter.date('1970-01-01', '2019-08-01'))
                  .map(clipper)
                  .map(addTime);
                  
var climateMedians = climate.reduce(ee.Reducer.median());

var months = ee.List.sequence(1, 12);

// Group by month, and then reduce within groups by mean();
// the result is an ImageCollection with one image for each
// month.
var byMonth = ee.ImageCollection.fromImages(
      months.map(function (m) {
        return climate.filter(ee.Filter.calendarRange(m, m, 'month'))
                    .select('pet').median()
                    .set('month', m);
}));
print(byMonth);

Map.addLayer(ee.Image(byMonth.first()));
/*
var months = ee.List.sequence(1, 12);

var composites = ee.ImageCollection.fromImages(months.map(function(m) {
  var filtered = climate.filter(ee.Filter.calendarRange({
    start: m,
    field: 'month'
  }));
  var composite = ee.Algorithms.Landsat.simpleComposite(filtered);
  return composite.normalizedDifference(['B4', 'B3']).rename('NDVI')
      .set('month', m);
}));
print(composites);

var check = ee.Image(composites.first());
Map.addLayer(check, {min: 0, max: 1}, 'check');
Map.addLayer(ee.Image(byMonth.first()));
*/
var pet = climateMedians.select('pet_median');
var petVis = {
  min: 500.0,
  max: 700.0,
  palette: [
    '1a3678', '2955bc', '5699ff', '8dbae9', 'acd1ff', 'caebff', 'e5f9ff',
    'fdffb4', 'ffe6a2', 'ffc969', 'ffa12d', 'ff7c1f', 'ca531a', 'ff0000',
    'ab0000'
  ],
};

Map.addLayer(pet, petVis,'Median PET');

// Load a MODIS collection, filter to several years of 16 day mosaics,
// and map the time band function over it.

/*
var collection = ee.ImageCollection('MODIS/006/MYD13A1')
  .filterDate('2000-01-01', '2019-08-01')
  .map(clipper)
  .map(addTime);

// Select the bands to model with the independent variable first.
var trend = collection.select(['system:time_start', 'NDVI'])
  // Compute the linear trend over time.
  .reduce(ee.Reducer.linearFit());

// Display the trend with increasing slopes in green, decreasing in red.
Map.addLayer(
    trend,
    {min: 0, max: [-100, 100, 10000], bands: ['scale', 'scale', 'offset']},
    'NDVI trend');

// Select the bands to model with the independent variable first.
*/
/*
var trend = climate.select(['system:time_start', 'tmmx'])
  // Compute the linear trend over time.
  .reduce(ee.Reducer.linearFit());
*/

/*
Export.image.toCloudStorage({
  image: elevation,
  description: 'srtm-dem',
  bucket: 'ikhnart',
  fileNamePrefix: 'geotiff/srtm-dem',
  scale: 30,
  region: features
});

Export.image.toCloudStorage({
  image: elevation,
  description: 'srtm-slope',
 bucket: 'ikhnart',
  fileNamePrefix: 'geotiff/srtm-slope',
  scale: 30,
  region: features
});
*/ivar ikhnart_bb = ee.FeatureCollection([
  ee.Feature(
    ee.Geometry.Rectangle(108.5471, 45.33891, 108.8689, 45.86695),
    {name: 'Ikh Nart'})]);
    
// initial variables
var geometry = ikhnart;
var clipper = function(img)
  {return img.clip(geometry)};
// Define a FeatureCollection: Ikh Nart and Do
var bands = ['B5', 'B4', 'B3', 'B2', 'B1'];
var L5coll = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')
.filter(ee.Filter.lt('CLOUD_COVER',25))
.select(bands)
.filterBounds(geometry)

var L7coll = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')
.filter(ee.Filter.lt('CLOUD_COVER',25))
.select(bands)
.filterBounds(geometry)
.map(function(image){
  var filled1a = image.focal_mean(1, 'square', 'pixels', 2)
  return filled1a.blend(image);
})

var L8coll = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
.filter(ee.Filter.lt('CLOUD_COVER',5))
.filterBounds(geometry)
.map(function(image){
  return image.rename(['B0', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B9', 'B10', 'B11']);
})
.select(bands);

// This function adds a band representing the image timestamp.
var addTime = function(image) {
  return image.addBands(image.metadata('system:time_start')
    .divide(1000 * 60 * 60 * 24 * 365));
};

var addNDVI = function(image) {
  var ndvi = image.normalizedDifference(['B4', 'B3']).rename('NDVI');
  return image.addBands(ndvi);
};

var fill = function(image){
                var filled1a = image.focal_mean(2, 'square', 'pixels', 1).blend(image);
                return filled1a.set('system:time_start',image.get('system:time_start'));
};

var landsat = ee.ImageCollection(L5coll.merge(L7coll.merge(L8coll)))
  .map(addNDVI)
  .map(fill);
  



//print(nullimages);

var years = ee.List.sequence(1984, 2019);
//print (years);

var collectYear = ee.ImageCollection(years
  .map(function(y) {
      var start = ee.Date.fromYMD(y, 1, 1)
      var end = start.advance(12, 'month');
      return landsat.filterDate(start, end).reduce(ee.Reducer.median())
  }));
  
/*
var medianFirst = collection_merge.first()
var finalCollection = nullimages.map(function(image){
  return image.visualize({bands: ['B3_median', 'B2_median', 'B1_median'], min: 300, max: 1800});
})
Map.addLayer(medianFirst, {bands: ['B3', 'B2', 'B1'], min: 0, max: 3000}, 'first image');
*/
/*
Export.video.toDrive({
  collection: finalCollection,
  description: 'yearly-ikhnart',
  dimensions: 1080,
  framesPerSecond: 1,
  region: geometry
});
*/

/*
var dem = ee.Image('USGS/SRTMGL1_003').clip(geometry);
var elevation = dem.select('elevation');
var slope = ee.Terrain.slope(elevation);

//Map.addLayer(features, {}, 'Ikh Nart')
Map.setCenter(108.7, 45.6, 9); // Ikh Nart
Map.addLayer(elevation, {min: 0, max:3500}, 'elevation')
Map.addLayer(slope, {min: 0, max: 60}, 'slope');
*/


var climate = ee.ImageCollection('IDAHO_EPSCOR/TERRACLIMATE')
                  .filter(ee.Filter.date('1970-01-01', '2019-08-01'))
                  .map(clipper)
                  .map(addTime);
                  
var climateMedians = climate.reduce(ee.Reducer.median());

var months = ee.List.sequence(1, 12);

// Group by month, and then reduce within groups by mean();
// the result is an ImageCollection with one image for each
// month.
var byMonth = ee.ImageCollection.fromImages(
      months.map(function (m) {
        return climate.filter(ee.Filter.calendarRange(m, m, 'month'))
                    .select('pet').median()
                    .set('month', m);
}));
print(byMonth);

Map.addLayer(ee.Image(byMonth.first()));
/*
var months = ee.List.sequence(1, 12);

var composites = ee.ImageCollection.fromImages(months.map(function(m) {
  var filtered = climate.filter(ee.Filter.calendarRange({
    start: m,
    field: 'month'
  }));
  var composite = ee.Algorithms.Landsat.simpleComposite(filtered);
  return composite.normalizedDifference(['B4', 'B3']).rename('NDVI')
      .set('month', m);
}));
print(composites);

var check = ee.Image(composites.first());
Map.addLayer(check, {min: 0, max: 1}, 'check');
Map.addLayer(ee.Image(byMonth.first()));
*/
var pet = climateMedians.select('pet_median');
var petVis = {
  min: 500.0,
  max: 700.0,
  palette: [
    '1a3678', '2955bc', '5699ff', '8dbae9', 'acd1ff', 'caebff', 'e5f9ff',
    'fdffb4', 'ffe6a2', 'ffc969', 'ffa12d', 'ff7c1f', 'ca531a', 'ff0000',
    'ab0000'
  ],
};

Map.addLayer(pet, petVis,'Median PET');

// Load a MODIS collection, filter to several years of 16 day mosaics,
// and map the time band function over it.

/*
var collection = ee.ImageCollection('MODIS/006/MYD13A1')
  .filterDate('2000-01-01', '2019-08-01')
  .map(clipper)
  .map(addTime);

// Select the bands to model with the independent variable first.
var trend = collection.select(['system:time_start', 'NDVI'])
  // Compute the linear trend over time.
  .reduce(ee.Reducer.linearFit());

// Display the trend with increasing slopes in green, decreasing in red.
Map.addLayer(
    trend,
    {min: 0, max: [-100, 100, 10000], bands: ['scale', 'scale', 'offset']},
    'NDVI trend');

// Select the bands to model with the independent variable first.
*/
/*
var trend = climate.select(['system:time_start', 'tmmx'])
  // Compute the linear trend over time.
  .reduce(ee.Reducer.linearFit());
*/

/*
Export.image.toCloudStorage({
  image: elevation,
  description: 'srtm-dem',
  bucket: 'ikhnart',
  fileNamePrefix: 'geotiff/srtm-dem',
  scale: 30,
  region: features
});

Export.image.toCloudStorage({
  image: elevation,
  description: 'srtm-slope',
 bucket: 'ikhnart',
  fileNamePrefix: 'geotiff/srtm-slope',
  scale: 30,
  region: features
});
*/
